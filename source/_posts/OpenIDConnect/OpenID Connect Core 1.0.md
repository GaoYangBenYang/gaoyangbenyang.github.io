---
title: OpenID Connect Core 1.0
date: 2023-04-5 14:44:06
author: GaoYang
img:
summary: 
categories:
- OpenID Connect
tags:
- OpenID Connect Core 1.0
---
# 摘要
OpenID Connect 1.0是OAuth 2.0协议之上的一个简单的身份层。它使客户端能够根据授权服务器执行的身份验证来验证最终用户的身份，并以可互操作和类似rest的方式获得关于最终用户的基本概要信息。

该规范定义了核心OpenID Connect功能:建立在OAuth 2.0之上的身份验证，并使用声明来传递有关最终用户的信息。它还描述了使用OpenID Connect的安全和隐私注意事项。


# 1.  简介
OpenID Connect 1.0是OAuth 2.0 [RFC6749]协议之上的一个简单的身份层。它使客户端能够根据授权服务器执行的身份验证来验证最终用户的身份，并以可互操作和类似rest的方式获得关于最终用户的基本概要信息。

OpenID Connect核心1.0规范定义了核心OpenID Connect功能:建立在OAuth 2.0之上的身份验证和使用声明来传递关于最终用户的信息。它还描述了使用OpenID Connect的安全和隐私注意事项。

作为背景，OAuth 2.0授权框架[RFC6749]和OAuth 2.0无记名令牌使用[RFC6750]规范为第三方应用程序提供了一个通用框架，以获取和使用对HTTP资源的有限访问。它们定义了获取和使用访问令牌访问资源的机制，但没有定义提供标识信息的标准方法。值得注意的是，如果不分析OAuth 2.0，它就无法提供关于最终用户身份验证的信息。读者应该熟悉这些规范。

OpenID Connect将身份验证实现为OAuth 2.0授权过程的扩展。客户端通过在授权请求中包含openid范围值来请求使用此扩展。关于执行身份验证的信息以JSON Web令牌(JWT) [JWT]形式返回，称为ID令牌(参见第2节)。实现OpenID连接的OAuth 2.0身份验证服务器也被称为OpenID提供者(OPs)。使用OpenID连接的OAuth 2.0客户端也被称为依赖方(RPs)。

本规范假设依赖方已经获得了关于OpenID提供者的配置信息，包括其授权端点和令牌端点位置。此信息通常通过发现获得，如OpenID Connect Discovery 1.0 [OpenID. net]中所述。或可通过其他机制获得。

同样，本规范假设依赖方已经获得了足够的凭据，并提供了使用OpenID提供者所需的信息。这通常是通过动态注册完成的，如OpenID连接动态客户端注册1.0 [OpenID.Discovery]，或可通过其他机制获得。
## 1.1.  需求、符号和约定
本文中关键字“必须”、“必须不”、“要求”、“应当”、“不应当”、“应该”、“不应该”、“建议”、“不建议”、“可能”和“可选”("MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL")的解释请参见RFC2119 [RFC2119]。

在本文档的.txt版本中，值被引用，以表明它们将被字面理解。在协议消息中使用这些值时，引号绝对不能用作值的一部分。在本文档的HTML版本中，使用这种固定宽度的字体来指示字面上的值。

在本规范中，JSON Web签名(JWS) [JWS]和JSON Web加密(JWE) [JWE]数据结构的所有使用都利用了JWS紧凑序列化或JWE紧凑序列化;没有使用JWS JSON Serialization和JWE JSON Serialization。

## 1.2.  术语

本规范使用OAuth 2.0 [RFC6749]定义的术语“访问令牌”、“授权代码”、“授权端点”、“授权授权”、“授权服务器”、“客户端”、“客户端认证”、“客户端标识符”、“授权类型”、“受保护资源”、“重定向URI”、“刷新令牌”、“资源所有者”、“资源服务器”、“响应类型”和“令牌端点”，术语“声明名称”、“声明值”、“JSON Web令牌(JWT)”、“JWT声明集”。和由JSON Web令牌(JWT) [JWT]定义的“嵌套JWT”，由JSON Web签名(JWS) [JWS]定义的术语“报头参数”和“JOSE报头”，由RFC2616 [RFC2616]定义的术语“用户代理”，以及由OAuth 2.0多响应类型编码实践[OAuth. responses]定义的术语“响应模式”。

本规范还定义了以下术语:

* Authentication (身份验证): 
  
  - 用于在实体和所呈现的身份之间实现足够信任的绑定的过程。

* Authentication Request (身份验证请求):
  
  - OAuth 2.0授权请求，使用OpenID连接定义的扩展参数和作用域，请求授权服务器(OpenID连接提供者[OpenID Connect Provider])对客户端(OpenID连接依赖方[OpenID Connect Relying Party])进行身份验证。

* Authentication Context (身份验证上下文): 
  
  - 依赖方(Relying Party)在对身份验证响应(authentication response)作出授权决定之前可能需要的信息。该上下文可以包括但不限于实际使用的认证方法或保证级别，例如ISO/IEC 29115 [ISO29115]实体认证保证级别。

* Authentication Context Class (认证上下文类): 
  
  - 在特定上下文中被认为彼此等效的一组身份验证方法或过程。

* Authentication Context Class Reference (认证上下文类引用):
  
  - 身份验证上下文类的标识符。

* Authorization Code Flow (授权码流): 
  
  -  OAuth 2.0流程，其中授权码从授权端点返回，所有令牌从令牌端点返回。

* Authorization Request (授权请求): 
  
  - OAuth 2.0授权请求[RFC6749]定义。

* Claim (索赔): 

  - 关于一个实体的断言信息。

* Claim Type (索赔类型): 

  - 用于表示索赔值的语法。该规范定义了正常、聚合和分布式索赔类型。

* Claims Provider (要求供应商): 

  - 可以返回关于实体的声明的服务器。

* Credential (凭证): 

  - 作为使用身份或其他资源的权利的证据的数据。

* End-User (终端用户): 

  - 人类的参与者。

* Entity (实体)：

  - 事物:具有独立的、独特的存在并能在某一语境中被识别的事物.终端用户是实体的一个例子。

* Essential Claim (基本要求)：

  - 客户端指定为确保最终用户请求的特定任务的顺利授权体验所必需的声明。

* Hybrid Flow (混合流)：

  - OAuth 2.0流程，其中从授权端点返回授权代码，从授权端点返回一些令牌，从令牌端点返回其他令牌。

* ID Token (标识牌)：

  - JSON Web令牌(JWT) [JWT]，包含关于身份验证事件的声明。它可能包含其他权利要求。

* Identifier (标识符)：

  - 该值在特定上下文中唯一地表征一个实体。

* Identity (身份)：

  - 与实体相关的属性集。

* Implicit Flow (隐式流)：

  - OAuth 2.0流，其中所有令牌都从授权端点返回，既不使用令牌端点也不使用授权代码。

* Issuer (发行人)：

  - 发布一组Claims的实体。

* Issuer Identifier (发行者标识符)：

  - 颁发者的可验证标识符。发布者标识符是一个大小写敏感的URL，使用https方案，包含方案、主机和可选的端口号和路径组件，没有查询或片段组件。

* Message (消息)

  - OpenID依赖方和OpenID提供者之间的请求或响应。

* OpenID Provider (OP) (OpenID提供者(OP))

  - OAuth 2.0授权服务器，能够对最终用户进行身份验证，并向依赖方提供关于身份验证事件和最终用户的声明。

* Request Object (请求对象)

  - 包含一组请求参数作为声明的JWT。

* Request URI (请求URI)

  - 引用包含请求对象的资源的URL。请求URI内容必须能被授权服务器检索到。

* Pairwise Pseudonymous Identifier (PPID) (成对假名标识符(PPID))

  - 向依赖方标识实体的标识符，该标识符不能与实体在另一个依赖方的PPID相关联。

* Personally Identifiable Information (PII) (个人身份资料(PII))

  - 可用于识别与该等信息相关的自然人的信息，或(b)与该等信息相关的自然人直接或间接相关的信息。

* Relying Party (RP) (依赖方(RP))

  - OAuth 2.0客户端应用程序需要终端用户身份验证和来自OpenID提供者的声明。

* Sector Identifier (企业标识符)

  - 依赖方的组织使用的URL的主机组件，作为依赖方的成对主题标识符计算的输入。

* Self-Issued OpenID Provider (自发OpenID提供者)

  - 发布自签名ID令牌的个人的、自托管的OpenID提供者。

* Subject Identifier (对象标识符)

  - 在颁发者中为最终用户在本地唯一且从未重新分配的标识符，该标识符将被客户端使用。

* UserInfo Endpoint (用户信息端点)

  - 受保护的资源，当客户端向其提供访问令牌时，返回有关由相应授权授予表示的最终用户的授权信息。UserInfo端点URL必须使用https方案，并且可以包含端口、路径和查询参数组件。


* Validation (验证)

  - 旨在建立一个结构的健全性或正确性的过程。


* Verification (验证)

  - 旨在检验或证明事实或价值的真实性或准确性的过程


* Voluntary Claim (自愿要求)

  - 客户指定的声明对于最终用户要求的特定任务是有用的，但不是必要的。


## 1.3.  概述
OpenID连接协议抽象地遵循以下步骤。

1. RP(客户端)向OpenID提供者(OP)发送一个请求。
2. OP对终端用户进行认证并获得授权。
3. OP响应一个ID令牌，通常是一个访问令牌。
4. RP可以向UserInfo端点发送带有访问令牌的请求。
5. UserInfo端点返回关于最终用户的声明。

这些步骤如下图所示:

```
+--------+                                   +--------+
|        |                                   |        |
|        |---------(1) AuthN Request-------->|        |
|        |                                   |        |
|        |  +--------+                       |        |
|        |  |        |                       |        |
|        |  |  End-  |<--(2) AuthN & AuthZ-->|        |
|        |  |  User  |                       |        |
|   RP   |  |        |                       |   OP   |
|        |  +--------+                       |        |
|        |                                   |        |
|        |<--------(3) AuthN Response--------|        |
|        |                                   |        |
|        |---------(4) UserInfo Request----->|        |
|        |                                   |        |
|        |<--------(5) UserInfo Response-----|        |
|        |                                   |        |
+--------+                                   +--------+
```
# 2.  标识牌(ID Token)
OpenID Connect对OAuth 2.0进行的主要扩展是ID Token数据结构，以允许对最终用户进行身份验证。ID Token是一种安全令牌，它包含在使用客户端时授权服务器对最终用户进行身份验证的声明，以及其他可能被请求的声明。ID Token表示为JSON Web Token(JWT)。

以下声明用于OpenID Connect使用的所有OAuth 2.0流的ID Token中:

* iss
  - 必需的。Issuer响应的颁发者标识符。iss值是一个大小写敏感的URL，使用https方案，包含方案、主机和可选的端口号和路径组件，没有查询或片段组件。

* sub
  - 必需的。对象标识符。在发行方内部为最终用户提供的本地唯一且从未重新分配的标识符，用于客户端使用，例如24400320或AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4。它的长度不能超过255个ASCII字符。sub是区分大小写的字符串。

* aud

    - 必需的。此ID令牌所针对的受众。它必须包含依赖方的OAuth 2.0 client_id作为受众值。它还可以包含其他受众的标识符。在一般情况下，aud值是一个区分大小写的字符串数组。在常见的特殊情况下，当只有一个受众时，aud值可以是一个区分大小写的字符串。

* exp

    - 必需的。在ID令牌不能被接受处理的过期时间或之后。此参数的处理要求当前日期/时间必须在值中列出的过期日期/时间之前。实现者可以提供一些小的回旋余地，通常不超过几分钟，以考虑时钟倾斜。它的值是一个JSON数字，表示从1970-01-01T0:0:0Z (UTC)到日期/时间的秒数。参见RFC3339 [RFC3339]了解有关一般日期/时间和特别UTC的详细信息。

* iat

    - 必需的。JWT发布的时间。它的值是一个JSON数字，表示从1970-01-01T0:0:0Z (UTC)到日期/时间的秒数。

* auth_time

    - 发生最终用户身份验证的时间。它的值是一个JSON数字，表示从1970-01-01T0:0:0Z (UTC)到日期/时间的秒数。当max_age请求或者auth_time作为Essential Claim请求时，这个Claim是REQUIRED;否则，它的包含是可选的。auth_time声明在语义上对应于OpenID 2.0的响应参数。

* nonce

    - 用于将客户端会话与ID令牌相关联并减轻重放攻击的字符串值。该值未经修改地从身份验证请求传递到ID令牌。如果出现在ID令牌中，客户端必须验证nonce声明值是否等于认证请求中发送的nonce参数的值。如果在认证请求中出现，授权服务器必须在ID令牌中包含一个nonce声明，声明值是在认证请求中发送的nonce值。授权服务器不应该对所使用的nonce值执行其他处理。nonce值是区分大小写的字符串。

* acr

    - 可选的。认证上下文类引用。指定身份验证上下文类参考值的字符串，该值标识执行身份验证时满足的身份验证上下文类。“0”表示终端用户认证不符合ISO/IEC 29115 [ISO29115]级别1的要求。例如，使用长期存在的浏览器cookie进行身份验证就是使用“级别0”是合适的一个例子。级别为0的身份验证不应该用于授权访问任何具有货币价值的资源。这对应于OpenID 2.0的PAPE [OpenID. PAPE]。 nist_auth_level 0。应该使用绝对URI或RFC6711 [RFC6711]注册名称作为acr值;已注册的名称绝对不能与已注册的名称具有不同的含义。使用此声明的各方需要就所使用的值的含义达成一致，这些值可能与上下文有关。acr是区分大小写的字符串。

* amr

    - 可选的。认证方法参考。JSON字符串数组，这些字符串是身份验证中使用的身份验证方法的标识符。例如，值可能表明同时使用了密码和OTP身份验证方法。在amr声明中使用的特定值的定义超出了本规范的范围。使用此声明的各方需要就所使用的值的含义达成一致，这些值可能与上下文有关。amr值是一个区分大小写的字符串数组。

* azp

    - 可选的。授权方-向其发出ID令牌的一方。如果存在，它必须包含此方的OAuth 2.0客户端ID。只有当ID令牌具有单一受众价值且受众不同于被授权方时，才需要此声明。即使被授权的一方是唯一的观众，也可以包括它。azp值是一个区分大小写的字符串，包含一个StringOrURI值。

ID令牌可能包含其他声明。任何不被理解的声明必须被忽略。有关本规范定义的其他权利要求，请参见第3.1.3.6、3.3.2.11、5.1和7.4节。

ID令牌必须使用JWS [JWS]进行签名，并且可选地分别使用JWS [JWS]和JWE [JWE]进行签名和加密，从而提供身份验证、完整性、不可否认性和可选的机密性(参见第16.14节)。如果ID令牌是加密的，它必须被签名，然后加密，结果是嵌套的JWT，如[JWT]中定义的那样。ID令牌绝对不能使用none作为alg值，除非所使用的响应类型从授权端点返回没有ID令牌(例如在使用授权代码流时)，并且客户端在注册时明确要求使用none。

ID令牌不应该使用JWS或JWE x5u, x5c, jku或jwk头参数字段。相反，根据第10节，使用Discovery和Registration参数提前传递对所使用的键的引用。

下面是ID令牌中索赔集(JWT索赔集)的一个非规范示例:
```
  {
   "iss": "https://server.example.com",
   "sub": "24400320",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "auth_time": 1311280969,
   "acr": "urn:mace:incommon:iap:silver"
  }
```
# 3.身份验证
OpenID Connect执行身份验证以登录最终用户或确定最终用户已经登录。OpenID Connect以安全的方式将服务器执行的身份验证结果返回给客户端，以便客户端可以依赖它。因此，在这种情况下，客户端被称为依赖方(RP)。

认证结果以ID令牌的形式返回，如第2节中定义的那样。它具有声明，表示诸如发行者、主题标识符、身份验证到期时间等信息。

身份验证可以遵循三种路径之一:授权代码流(response_type= Code)、隐式流(response_type=id_token token或response_type=id_token)或混合流(使用OAuth 2.0多响应类型编码实践[OAuth. responses]中定义的其他响应类型值)。这些流决定如何将ID令牌和访问令牌返回给客户端。

下面的非规范表总结了这三种流的特征。该表旨在为在特定上下文中选择哪个流提供一些指导。
| Property | Authorization Code Flow | Implicit Flow | Hybrid Flow |
| :----:| :----: | :----: | :----: |
| 从授权端点返回的所有令牌 | × | √ | × |
| 从令牌端点返回的所有令牌 | √ | × | × |
| 没有向用户代理显示令牌 | √ | × | × |
| 客户端可以验证 | √ | × | √ |
| 可能会刷新令牌 | √ | × | √ |
| 一次往返的通信 | × | √ | × |
| 大多数服务器到服务器的通信 | √ | × | 不同 |

使用的流由授权请求中包含的response_type值决定。这些response_type值选择以下流:
| "response_type" value | Flow |
| :----:| :----: | 
| code | Authorization Code Flow |
| id_token | Implicit Flow |
| id_token token | Implicit Flow |
| code id_token | 	Hybrid Flow |
| code token | 	Hybrid Flow |
| code id_token token | Hybrid Flow |

除了OAuth 2.0 [RFC6749]定义的代码响应类型值外，其他所有的值都在OAuth 2.0多响应类型编码实践[OAuth.Responses)规范。注意:虽然OAuth 2.0还为隐式流定义了令牌响应类型值，但OpenID连接不使用此响应类型，因为不会返回ID令牌。

## 3.1.  使用授权代码流进行身份验证

介绍如何使用授权码流进行鉴权。当使用授权代码流时，所有令牌都从令牌端点返回。

授权码流将授权码返回给客户端，然后客户端可以直接将其交换为ID令牌和访问令牌。这样做的好处是不会将任何令牌暴露给用户代理以及可能访问用户代理的其他恶意应用程序。授权服务器还可以在将授权码交换为访问令牌之前对客户端进行身份验证。授权代码流适用于能够安全地在自己和授权服务器之间维护客户端机密的客户端。

### 3.1.1.  授权码流步骤

授权代码流执行以下步骤。

1. 客户端准备一个包含所需请求参数的身份验证请求。
2. 客户端将请求发送到授权服务器。
3. 授权服务器对终端用户进行认证。
4. 授权服务器获得最终用户同意/授权。
5. 授权服务器用授权代码将最终用户发送回客户端。
6. 客户端在令牌端点使用授权码请求响应。
7. 客户端接收到响应体中包含ID令牌和访问令牌的响应。
8. 客户端验证ID令牌并检索最终用户的主题标识符。
   
### 3.1.2.  授权端点

授权端点执行最终用户的身份验证。这是通过将用户代理发送到授权服务器的授权端点进行身份验证和授权来实现的，使用OAuth 2.0定义的请求参数和OpenID Connect定义的附加参数和参数值。

与授权端点的通信必须使用TLS。有关使用TLS的更多信息，请参阅第16.17节。

#### 3.1.2.1.  身份验证请求
身份验证请求是OAuth 2.0授权请求，它请求授权服务器对最终用户进行身份验证。

授权服务器必须支持在授权端点使用RFC2616 [RFC2616]中定义的HTTP GET和POST方法。客户端可以使用HTTP GET或POST方法向授权服务器发送授权请求。如果使用HTTP GET方法，请求参数将使用URI查询字符串序列化序列化，参见章节13.1。如果使用HTTP POST方法，请求参数将使用表单序列化(参见章节13.2)进行序列化。

OpenID连接使用授权代码流中的以下OAuth 2.0请求参数:

* scope

    - 必需的。OpenID连接请求必须包含OpenID范围值。如果openid范围值不存在，则行为完全未指定。可能会出现其他范围值。不能被实现理解的作用域值应该被忽略。有关本规范定义的其他范围值，请参见第5.4节和第11节。

* response_type

    - 必需的。OAuth 2.0响应类型值，它确定要使用的授权处理流，包括从使用的端点返回哪些参数。使用授权代码流时，此值为Code。

* client_id

    - 必需的。在授权服务器上有效的OAuth 2.0客户端标识符。

* redirect_uri

    - 必需的。将响应发送到的重定向URI。这个URI必须精确匹配预先在OpenID提供者中注册的客户端的重定向URI值之一，并按照[RFC3986](简单字符串比较)第6.2.1节的描述进行匹配。当使用这个流时，重定向URI应该使用https方案;但是，它可以使用http方案，前提是客户端类型是机密的，就像OAuth 2.0的2.1节中定义的那样，并且在这种情况下OP允许使用http重定向uri。重定向URI可以使用另一种方案，例如用于标识本机应用程序的回调的方案。

* state

    - 推荐。用于维护请求和回调之间的状态的不透明值。通常，通过加密方式将该参数的值与浏览器cookie绑定，可以缓解跨站点请求伪造(CSRF、XSRF)。

OpenID连接还使用以下OAuth 2.0请求参数，该参数在OAuth 2.0多响应类型编码实践[OAuth.Responses]:

* response_mode
  
    - 可选的。通知授权服务器将用于从授权端点返回参数的机制。当请求的响应模式为响应类型指定的默认模式时，不建议使用此参数。

该规范还定义了以下请求参数:

* nonce
    - 可选的。用于将客户端会话与ID令牌相关联并减轻重放攻击的字符串值。该值未经修改地从身份验证请求传递到ID令牌。在nonce值中必须存在足够的熵，以防止攻击者猜测值。有关实现注意事项，请参见15.5.2节。

* display
    - 可选的。指定授权服务器如何向最终用户显示身份验证和同意用户界面页面的ASCII字符串值。定义的值为:
        - page
            - 授权服务器应该显示与完整的用户代理页面视图一致的身份验证和同意UI。如果不指定display参数，则默认显示方式为display。
        - popup
            - 授权服务器应该显示与弹出的用户代理窗口一致的身份验证和同意UI。弹出式User Agent窗口的大小应该适合以登录为重点的对话框，并且不应该遮住它弹出的整个窗口。
        - touch
            - 授权服务器应该显示与使用触摸界面的设备一致的身份验证和同意UI。
        - wap
            - 授权服务器应该显示与“功能手机”类型显示一致的身份验证和同意UI。

授权服务器还可以尝试检测用户代理的功能并显示适当的显示。

* prompt
    - 可选的。空格分隔、区分大小写的ASCII字符串值列表，用于指定授权服务器是否提示最终用户进行重新身份验证和同意。定义的值为:
        - none
            - 授权服务器绝对不能显示任何身份验证或同意用户界面页面。如果最终用户尚未进行身份验证，或客户端未对请求的索赔要求获得预先配置的同意，或未满足处理请求的其他条件，则返回错误。错误代码通常是login_required、interaction_required或章节3.1.2.6中定义的其他代码。这可以用作检查现有身份验证和/或同意的方法。
        - login
            - 授权服务器应提示最终用户重新进行身份验证。如果它不能重新验证最终用户，它必须返回一个错误，通常是login_required。
        - consent
            - 授权服务器在向客户端返回信息之前应提示最终用户同意。如果它不能获得同意，它必须返回一个错误，通常是consent_required。
        - select_account
            - 授权服务器应该提示最终用户选择一个用户帐户。这使得在授权服务器上拥有多个帐户的最终用户可以在可能拥有当前会话的多个帐户中进行选择。如果它不能获得最终用户做出的帐户选择，它必须返回一个错误，通常是account_selection_required。

客户端可以使用prompt参数来确保终端用户仍然存在于当前会话中，或者引起对请求的注意。如果此参数不包含任何其他值，则返回错误。

* max_age
    - 可选的。最大认证年龄。指定自OP最后一次主动验证终端用户以来允许的运行时间(以秒为单位)。如果运行时间大于此值，OP必须尝试主动重新验证终端用户。max_age请求参数对应OpenID 2.0 PAPE。max_auth_age请求参数)当使用max_age时，返回的ID令牌必须包含auth_time Claim Value。
* ui_locales
    - 可选的。用户界面的最终用户首选语言和脚本，以空格分隔的BCP47 [RFC5646]语言标记值列表表示，按首选项排序。例如，值“fr- ca fr en”表示首选在加拿大使用的法语，然后是法语(没有地区指定)，最后是英语(没有地区指定)。如果OpenID提供者不支持所请求的部分或全部区域设置，则不应导致错误。
* id_token_hint
    - 可选的。先前由授权服务器发出的ID令牌被作为终端用户当前或过去与客户端经过身份验证的会话的提示传递。如果由ID令牌标识的最终用户已登录或已被请求登录，则授权服务器将返回积极响应;否则，它应该返回一个错误，例如login_required。在可能的情况下，当prompt=none使用时，id_token_hint应该出现，如果不使用则可能返回invalid_request错误;但是，服务器应该在可能的情况下成功响应，
* login_hint
    - 可选的。向授权服务器提示终端用户登录时可能使用的登录标识符(如有必要)。如果RP首先向最终用户询问他们的电子邮件地址(或其他标识符)，然后希望将该值作为提示传递给发现的授权服务，则可以使用此提示。建议提示值与用于发现的值匹配。这个值也可以是phone_number声明中指定格式的电话号码。该参数的使用由OP自行决定。
* acr_values
    - 可选的。请求的认证上下文类参考值。空格分隔的字符串，指定请求授权服务器用于处理此身份验证请求的acr值，这些值按优先级顺序显示。执行的身份验证所满足的身份验证上下文类作为acr声明值返回，如第2节所述。通过此参数，acr索赔被请求为自愿索赔。

其他参数可能被发送。有关本规范定义的其他授权请求参数和参数值，请参见第3.2.2、3.3.2、5.2、5.5、6和7.2.1节。

下面是客户端HTTP 302重定向响应的非规范示例，它触发用户代理向授权端点发出身份验证请求(仅为显示目的在值中使用换行):
```
HTTP/1.1 302 Found
  Location: https://server.example.com/authorize?
    response_type=code
    &scope=openid%20profile%20email
    &client_id=s6BhdRkqt3
    &state=af0ifjsldkj
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
```

下面是用户代理发送到授权服务器的非规范示例请求，以响应上面客户端的HTTP 302重定向响应(仅为显示目的在值中使用换行):
```
  GET /authorize?
    response_type=code
    &scope=openid%20profile%20email
    &client_id=s6BhdRkqt3
    &state=af0ifjsldkj
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
  Host: server.example.com
```

#### 3.1.2.2.  验证请求验证

授权服务器必须按照以下方式验证收到的请求:

1. 授权服务器必须根据OAuth 2.0规范验证所有OAuth 2.0参数。
2. 验证是否存在scope参数并包含openid范围值。(如果没有openid范围值，请求可能仍然是有效的OAuth 2.0请求，但不是openid连接请求。)
3. 授权服务器必须验证是否存在所有必需的参数，并且它们的使用符合此规范。
4. 如果sub(subject)声明被请求为ID令牌的特定值，授权服务器必须仅在由该子值标识的最终用户与授权服务器有活动会话或已作为请求的结果进行了身份验证时才发送正面响应。授权服务器绝对不能为不同的用户回复ID令牌或访问令牌，即使他们与授权服务器有活动会话。如果实现支持Claim参数，可以使用id_token_hint参数发出这样的请求，也可以像第5.5.1节中描述的那样请求特定的Claim Value。

根据OAuth 2.0 [RFC6749]的规定，授权服务器应该忽略不可识别的请求参数。

如果授权服务器遇到任何错误，它必须返回一个错误响应，参见章节3.1.2.6。

#### 3.1.2.3.  授权服务器对最终用户进行认证
如果请求有效，授权服务器将尝试对最终用户进行身份验证或确定最终用户是否已经过身份验证，这取决于所使用的请求参数值。授权服务器用于验证最终用户的方法(例如用户名和密码、会话cookie等)超出了本规范的范围。授权服务器可以显示身份验证用户界面，这取决于使用的请求参数值和使用的身份验证方法。

在以下情况下，授权服务器必须尝试验证最终用户:

* 最终用户尚未经过身份验证。
* 身份验证请求包含值为login的提示参数。在这种情况下，授权服务器必须重新验证最终用户，即使最终用户已经通过了身份验证。

在以下情况下，授权服务器绝对不能与最终用户交互:

* 认证请求包含值为none的提示参数。在这种情况下，如果最终用户尚未经过身份验证或无法进行静默身份验证，授权服务器必须返回一个错误。

在与最终用户交互时，授权服务器必须采取适当的措施防止跨站请求伪造和点击劫持，如OAuth 2.0 [RFC6749]第10.12和10.13节所述。
#### 3.1.2.4.  授权服务器获得最终用户同意/授权
#### 3.1.2.5.  认证响应成功
#### 3.1.2.6.  认证错误响应
#### 3.1.2.7.  验证响应验证
### 3.1.3.  令牌端点
#### 3.1.3.1.  令牌的请求
#### 3.1.3.2.  令牌请求验证
#### 3.1.3.3.  Token成功响应
#### 3.1.3.4.  令牌错误响应
#### 3.1.3.5.  令牌响应验证
#### 3.1.3.6.  标识牌
#### 3.1.3.7.  ID令牌验证
#### 3.1.3.8.  访问令牌验证
## 3.2.  使用隐式流进行身份验证
### 3.2.1.  隐式流程步骤
### 3.2.2.  授权端点
#### 3.2.2.1.  身份验证请求
#### 3.2.2.2.  验证请求验证
#### 3.2.2.3.  授权服务器对最终用户进行认证
#### 3.2.2.4.  授权服务器获得最终用户同意/授权
#### 3.2.2.5.  认证响应成功
#### 3.2.2.6.  认证错误响应
#### 3.2.2.7.  重定向URI片段处理
#### 3.2.2.8.  验证响应验证
#### 3.2.2.9.  访问令牌验证
#### 3.2.2.10.  标识牌
#### 3.2.2.11.  ID令牌验证
## 3.3.  使用混合流进行身份验证
### 3.3.1.  混合流程步骤
### 3.3.2.  授权端点
#### 3.3.2.1.  身份验证请求
#### 3.3.2.2.  验证请求验证
#### 3.3.2.3.  授权服务器对最终用户进行认证
#### 3.3.2.4.  授权服务器获得最终用户同意/授权
#### 3.3.2.5.  认证响应成功
#### 3.3.2.6.  认证错误响应
#### 3.3.2.7.  重定向URI片段处理
#### 3.3.2.8.  验证响应验证
#### 3.3.2.9.  访问令牌验证
#### 3.3.2.10.  授权码验证
#### 3.3.2.11.  标识牌
#### 3.3.2.12.  ID令牌验证
### 3.3.3.  令牌端点
#### 3.3.3.1.  令牌的请求
#### 3.3.3.2.  令牌请求验证
#### 3.3.3.3.  Token成功响应
#### 3.3.3.4.  令牌错误响应
#### 3.3.3.5.  令牌响应验证
#### 3.3.3.6.  标识牌
#### 3.3.3.7.  ID令牌验证
#### 3.3.3.8.  访问令牌
#### 3.3.3.9.  访问令牌验证
# 4.  从第三方发起登录
# 5.  索赔
## 5.1.  标准要求
### 5.1.1.  解决索赔
### 5.1.2.  额外的要求
## 5.2.  索赔语言和脚本
## 5.3.  用户信息端点
### 5.3.1.  用户信息请求
### 5.3.2.  UserInfo成功响应
### 5.3.3.  UserInfo错误响应
### 5.3.4.  UserInfo响应验证
## 5.4.  使用范围值请求声明
## 5.5.  使用" Claims "请求参数请求索赔
### 5.5.1.  个别索偿申请
#### 5.5.1.1.  请求“acr”索赔
### 5.5.2.  个人索赔的语言和脚本
## 5.6.  索赔类型
### 5.6.1.  正常的索赔
### 5.6.2.  聚合和分布式索赔
#### 5.6.2.1.  综合申索的例子
#### 5.6.2.2.  分布式索赔示例
## 5.7.  索赔稳定性和唯一性
# 6.  将请求参数作为jwt传递
## 6.1.  按值传递请求对象
### 6.1.1.  使用" Request "请求参数请求
## 6.2.  通过引用传递请求对象
### 6.2.1.  URL引用请求对象
### 6.2.2.  使用“request_uri”请求参数请求
### 6.2.3.  授权服务器获取请求对象
### 6.2.4.  “request_uri”原理
## 6.3.  验证基于jwt的请求
### 6.3.1.  加密请求对象
### 6.3.2.  已签名请求对象
### 6.3.3.  请求参数组装和验证
# 7.  自发OpenID提供者
## 7.1.  自发OpenID提供者发现
## 7.2.  自发OpenID提供者注册
### 7.2.1.  使用“注册”请求参数提供信息
## 7.3.  自发OpenID提供者请求
## 7.4.  自发OpenID提供者响应
## 7.5.  自发ID令牌验证
# 8.  主题标识符类型
## 8.1.  成对标识算法
# 9.  客户端身份验证
# 10.   签名与加密
## 10.1.  签署
### 10.1.1.  旋转非对称签名密钥
## 10.2.  加密
### 10.2.1.